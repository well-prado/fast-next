# Context

> Master application context in Igniter.js with static and dynamic patterns for request-scoped data, dependency injection, and type-safe access.
> URL: https://igniterjs.com/docs/core/context

## Overview

**Context** is the foundation of your Igniter.js application. It provides shared data and dependencies that are available to every action, procedure, and middleware throughout your API.

```typescript
import { Igniter } from "@igniter-js/core";

// Define context factory function in src/igniter.context.ts
export function createIgniterAppContext(): AppContext {
  return {
    db: new Database(),
    config: loadAppConfig(),
    services: {
      email: new EmailService(),
      storage: new StorageService(),
    },
  };
}

const igniter = Igniter.context(createIgniterAppContext()).create();
```

<Callout type="info" title="What is Context?">
  Context is an object containing your application's dependencies (database, services, configuration) and request-specific data (user, session, request ID) that flows through every action.
</Callout>

---

## Context Types

Igniter.js supports two context patterns:

### Static Context

A **fixed object** that remains the same for all requests. Best for:

- ✅ Database connections
- ✅ Service instances
- ✅ Application configuration
- ✅ Shared utilities

```typescript
// src/igniter.context.ts
interface AppContext {
  db: Database;
  config: AppConfig;
  services: {
    email: EmailService;
    storage: StorageService;
  };
}

export function createIgniterAppContext(): AppContext {
  return {
    db: new Database(),
    config: loadAppConfig(),
    services: {
      email: new EmailService(),
      storage: new StorageService(),
    },
  };
}

// src/igniter.ts
const igniter = Igniter.context(createIgniterAppContext()).create();
```

### Dynamic Context (Callback)

A **function** that creates context for each request. Best for:

- ✅ User authentication
- ✅ Session management
- ✅ Request IDs
- ✅ Per-request telemetry

```typescript
type ContextCallback = (req: Request) => Promise<AppContext> | AppContext;

const igniter = Igniter.context(async (req: Request) => {
  const session = await getSession(req);
  const user = session ? await db.users.findById(session.userId) : null;

  return {
    db,
    user,
    session,
    requestId: crypto.randomUUID(),
    ip: req.headers.get("x-forwarded-for") || "unknown",
  };
}).create();
```

---

## Static Context

### Defining Static Context

Use a type parameter to define your context shape:

```typescript
import { Igniter } from "@igniter-js/core";
import { db } from "./lib/database";
import { emailService } from "./lib/email";
import { storageService } from "./lib/storage";

interface AppContext {
  db: Database;
  email: EmailService;
  storage: StorageService;
  config: {
    apiUrl: string;
    env: "development" | "production";
  };
}

const igniter = Igniter.context(createIgniterAppContext()).create();
```

<Callout type="warn" title="Type Only">
  With static context using `.context<T>()`, you're only defining the **type**. The actual context object is typically provided globally or through your framework's environment.
</Callout>

### Accessing Static Context

```typescript
const userController = igniter.controller({
  path: "/users",
  actions: {
    list: igniter.query({
      handler: async ({ context, response }) => {
        // ✅ context.db is fully typed as Database
        const users = await context.db.users.findMany();

        // ✅ context.email is EmailService
        await context.email.send({
          to: "admin@example.com",
          subject: "Users listed",
          body: `Found ${users.length} users`,
        });

        return response.success({ users });
      },
    }),
  },
});
```

### When to Use Static Context

Use static context when:

- Your dependencies don't change per request
- You don't need per-request isolation
- You want simpler configuration
- Performance is critical (no callback overhead)

**Example: Shared Services**

```typescript
import { PrismaClient } from "@prisma/client";
import { Redis } from "ioredis";

const db = new PrismaClient();
const redis = new Redis();

interface AppContext {
  db: typeof db;
  redis: typeof redis;
  env: {
    nodeEnv: string;
    apiUrl: string;
  };
}

const igniter = Igniter.context(createIgniterAppContext()).create();
```

---

## Dynamic Context (Callback)

### Defining Dynamic Context

Pass a function that receives the `Request` object and returns context:

```typescript
import { Igniter } from "@igniter-js/core";

const igniter = Igniter.context(async (req: Request) => {
  // Extract auth token
  const token = req.headers.get("authorization")?.replace("Bearer ", "");

  // Get user from token
  const user = token ? await getUserFromToken(token) : null;

  // Get session
  const sessionId = req.headers.get("x-session-id");
  const session = sessionId ? await getSession(sessionId) : null;

  return {
    db,
    user,
    session,
    requestId: crypto.randomUUID(),
    timestamp: new Date(),
    ip:
      req.headers.get("x-forwarded-for") ||
      req.headers.get("x-real-ip") ||
      "unknown",
    userAgent: req.headers.get("user-agent") || "unknown",
  };
}).create();
```

### Accessing Dynamic Context

The context is **created fresh for each request** and injected into every action:

```typescript
const userController = igniter.controller({
  path: "/users",
  actions: {
    me: igniter.query({
      handler: async ({ context, response }) => {
        // ✅ context.user is inferred from callback return type
        if (!context.user) {
          return response.unauthorized({
            message: "Authentication required",
          });
        }

        // ✅ Access request-specific data
        console.log("Request ID:", context.requestId);
        console.log("User IP:", context.ip);

        return response.success({
          user: context.user,
          session: context.session,
        });
      },
    }),
  },
});
```

### When to Use Dynamic Context

Use dynamic context when:

- You need authentication/authorization
- You want per-request isolation
- You need request-specific metadata (IDs, timestamps)
- You have request-dependent dependencies

**Example: Multi-Tenant Application**

```typescript
const igniter = Igniter.context(async (req: Request) => {
  // Extract tenant from subdomain or header
  const hostname = new URL(req.url).hostname;
  const tenant = hostname.split(".")[0];

  // Get tenant-specific database
  const db = await getTenantDatabase(tenant);

  // Get user
  const user = await getUserFromRequest(req);

  return {
    tenant,
    db,
    user,
    requestId: crypto.randomUUID(),
  };
}).create();
```

---

## Type Inference

### Automatic Inference from Callback

TypeScript automatically infers the context type from your callback's return value:

```typescript
const igniter = Igniter.context(async (req: Request) => {
  return {
    db: database,
    user: await getUser(req),
    timestamp: new Date(),
  };
}).create();

// ✅ Context type is automatically:
// {
//   db: typeof database;
//   user: User | null;
//   timestamp: Date;
// }
```

### Explicit Type Annotation

You can also explicitly type the callback:

```typescript
interface AppContext {
  db: Database;
  user: User | null;
  requestId: string;
}

const igniter = Igniter.context(async (req: Request): Promise<AppContext> => {
  return {
    db: database,
    user: await getUser(req),
    requestId: crypto.randomUUID(),
  };
}).create();
```

### Extracting Context Type

Get the context type from your router:

```typescript
const AppRouter = igniter.router({
  controllers: { users: userController },
});

// Extract context type
type AppContext = typeof AppRouter.$Infer.$context;

// Use in external functions
async function getUserData(context: AppContext) {
  return context.db.users.findMany();
}
```

---

## Context with Procedures

Procedures can **extend the context** by adding new properties:

```typescript
import { igniter } from "@/igniter";

// Create auth procedure that adds `currentUser`
const authProcedure = igniter.procedure({
  handler: async ({ context, request }) => {
    const token = request.headers.get("authorization");

    if (!token) {
      throw new Error("No authorization token");
    }

    const user = await verifyToken(token);

    // ✅ Extend context with currentUser
    return {
      currentUser: user,
    };
  },
});

// Use in action
const protectedController = igniter.controller({
  path: "/protected",
  actions: {
    getData: igniter.query({
      path: "/",
      procedures: [authProcedure],
      handler: async ({ context, response }) => {
        // ✅ context.currentUser is available!
        console.log("Current user:", context.currentUser);

        return response.success({
          message: `Hello, ${context.currentUser.name}`,
        });
      },
    }),
  },
});
```

<Callout type="success" title="Type-Safe Extension">
  The context type automatically includes properties added by procedures. Full IntelliSense!
</Callout>

---

## Context Best Practices

### 1. Keep Context Lightweight

Don't load unnecessary data in context:

```typescript
// ❌ Bad - Loading everything upfront
const igniter = Igniter.context(async (req: Request) => {
  const user = await getUser(req);
  const posts = await db.posts.findMany({ userId: user.id }); // ❌ Not always needed
  const comments = await db.comments.findMany({ userId: user.id }); // ❌ Not always needed

  return { db, user, posts, comments };
}).create();

// ✅ Good - Load only what's needed
const igniter = Igniter.context(async (req: Request) => {
  const user = await getUser(req);

  return { db, user }; // ✅ Load posts/comments in actions when needed
}).create();
```

### 2. Use Lazy Loading

Create helper functions for optional data:

```typescript
const igniter = Igniter.context(async (req: Request) => {
  const userId = await getUserIdFromToken(req);

  return {
    db,
    userId,
    // ✅ Lazy loader for user data
    getUser: async () => {
      return userId ? await db.users.findById(userId) : null;
    },
    // ✅ Lazy loader for permissions
    getPermissions: async () => {
      return userId ? await db.permissions.findMany({ userId }) : [];
    },
  };
}).create();

// Usage in action
const userController = igniter.controller({
  actions: {
    profile: igniter.query({
      handler: async ({ context, response }) => {
        // Only loads user if needed
        const user = await context.getUser();
        return response.success({ user });
      },
    }),
  },
});
```

### 3. Cache Expensive Operations

Use memoization for expensive context operations:

```typescript
const igniter = Igniter.context(async (req: Request) => {
  const userId = await getUserIdFromToken(req);

  // ✅ Cache user data
  let cachedUser: User | null = null;

  return {
    db,
    userId,
    getUser: async () => {
      if (!cachedUser && userId) {
        cachedUser = await db.users.findById(userId);
      }
      return cachedUser;
    },
  };
}).create();
```

### 4. Separate Concerns

Structure context into logical groups:

```typescript
const igniter = Igniter
  .context(async (req: Request) => {
    return {
      // Database
      db: database,

      // Authentication
      auth: {
        user: await getUser(req),
        session: await getSession(req),
        permissions: await getPermissions(req)
      },

      // Request metadata
      meta: {
        requestId: crypto.randomUUID(),
        timestamp: new Date(),
        ip: req.headers.get('x-forwarded-for') || 'unknown'
      },

      // Services
      services: {
        email: emailService,
        storage: storageService,
        analytics: analyticsService
      }
    };
  })
  .create();

// Usage
const handler = async ({ context, response }) => {
  console.log('User:', context.auth.user);
  console.log('Request ID:', context.meta.requestId);
  await context.services.email.send({ ... });
};
```

---

## Advanced Patterns

### Conditional Context

Adjust context based on request properties:

```typescript
const igniter = Igniter.context(async (req: Request) => {
  const isAdmin = req.headers.get("x-admin-key") === process.env.ADMIN_KEY;

  return {
    db,
    user: await getUser(req),
    isAdmin,
    // ✅ Admin-only database access
    adminDb: isAdmin ? adminDatabase : null,
  };
}).create();
```

### Multi-Tenant Context

Route requests to tenant-specific resources:

```typescript
const igniter = Igniter.context(async (req: Request) => {
  // Extract tenant from header or subdomain
  const tenant = req.headers.get("x-tenant-id") || extractTenantFromHost(req);

  if (!tenant) {
    throw new Error("Tenant not specified");
  }

  // Get tenant-specific database connection
  const db = await getTenantDatabase(tenant);

  return {
    tenant,
    db,
    user: await getUser(req),
    requestId: crypto.randomUUID(),
  };
}).create();
```

### Request Tracing Context

Add distributed tracing metadata:

```typescript
const igniter = Igniter.context(async (req: Request) => {
  const traceId = req.headers.get("x-trace-id") || crypto.randomUUID();
  const spanId = crypto.randomUUID();

  return {
    db,
    user: await getUser(req),
    trace: {
      traceId,
      spanId,
      parentSpanId: req.headers.get("x-parent-span-id") || null,
    },
  };
}).create();
```

---

## Context vs Procedures

| Feature          | Context                   | Procedures                |
| ---------------- | ------------------------- | ------------------------- |
| **When runs**    | Once per request          | For specific actions      |
| **Purpose**      | Provide base dependencies | Add action-specific logic |
| **Scope**        | All actions               | Selected actions          |
| **Type merging** | Base type                 | Extends base type         |
| **Performance**  | Runs for every request    | Runs only when needed     |

**Use context for:**

- Database connections
- Core services
- Request metadata
- User authentication (basic)

**Use procedures for:**

- Role-based authorization
- Input transformation
- Rate limiting
- Action-specific enrichment

---

## Complete Example

Here's a production-ready context setup:

```typescript
import { Igniter } from "@igniter-js/core";
import { PrismaClient } from "@prisma/client";
import { Redis } from "ioredis";

// Services
const db = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL);
const emailService = createEmailService();

// Context callback
const igniter = Igniter.context(async (req: Request) => {
  // Extract request metadata
  const requestId = crypto.randomUUID();
  const ip = req.headers.get("x-forwarded-for") || "unknown";
  const userAgent = req.headers.get("user-agent") || "unknown";

  // Authentication
  const token = req.headers.get("authorization")?.replace("Bearer ", "");
  let user = null;
  let session = null;

  if (token) {
    try {
      const decoded = await verifyJWT(token);
      user = await db.users.findUnique({ where: { id: decoded.userId } });
      session = await redis.get(`session:${decoded.sessionId}`);
    } catch (error) {
      console.error("Auth error:", error);
    }
  }

  return {
    // Core dependencies
    db,
    redis,

    // Services
    email: emailService,

    // Authentication
    user,
    session,

    // Request metadata
    requestId,
    ip,
    userAgent,
    timestamp: new Date(),

    // Feature flags
    features: {
      enableAnalytics: process.env.FEATURE_ANALYTICS === "true",
      enableNotifications: process.env.FEATURE_NOTIFICATIONS === "true",
    },
  };
}).create();

export { igniter };
```

---

## Next Steps

<Cards>
  <Card title="Procedures" href="/docs/procedures">
    Learn how to extend context with reusable middleware
  </Card>

  <Card title="Actions" href="/docs/actions">
    Use context in queries and mutations
  </Card>

  <Card title="Error Handling" href="/docs/error-handling">
    Handle context errors gracefully
  </Card>

  <Card title="Testing" href="/docs/testing">
    Mock context for unit tests
  </Card>
</Cards>
