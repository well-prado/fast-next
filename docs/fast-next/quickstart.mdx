# Quickstart

Follow this checklist to get the Fast Next stack running locally and understand the moving parts before building your first feature.

## 1. Install dependencies

```bash
pnpm install
```

> pnpm 9+ is required. Node 18.18+ recommended (Next 16 + Fastify 5 support).

## 2. Scaffold the Fastify bridge (optional)

Setting up a new Next.js app? Let the CLI drop in the boilerplate routes and server helpers:

```bash
npx create-fast-next init .
pnpm dlx create-fast-next init .
yarn create fast-next init .
bunx create-fast-next init .
```

Pass `--install auto` (or `--install pnpm|npm|yarn|bun`) to have the CLI add dependencies. Need BullMQ scaffolding? Append `--with-queue`. Need caching? Use `--with-cache redis|upstash|memory`. Want MCP tooling or Docker compose? Use `--with-mcp` / `--with-docker`. Need another domain slice later? Swap `init` for `feature <name>` in any of the commands above, e.g. `npx create-fast-next feature projects`.

When Docker files are generated, run `pnpm docker:up` to boot the stack (app + Postgres + Redis + MCP) and `pnpm docker:down` when you’re done. Logs are available via `pnpm docker:logs`.

See the [CLI reference](./cli.mdx) for all options.

## 3. Run the web app

```bash
pnpm --filter web dev
```

This boots Next.js on `http://localhost:3000` and mounts the Fastify instance behind the `/api/*` catch-all route.

## 4. Smoke test the HTTP path

```bash
curl http://localhost:3000/api/health
curl http://localhost:3000/api/users/1
```

Both responses come from Fastify handlers defined in `apps/web/src/server/routes/index.ts`.

## 5. Inspect the server + query client demo

Open `apps/web/app/page.tsx`. The default home page is an **async Server Component** that fetches a featured user via:

```ts
const result = await api.users.get.query({
  params: { id: "1" },
});
```

That `api` instance is generated automatically by `createServerClient` (`apps/web/src/server/api.ts`) and backed by the Fastify server caller—zero HTTP hop, full type safety.

Need batching or cache semantics? Use the query client:

```ts
await queryClient.fetchQuery("users", "get", {
  params: { id: "1" },
});
```

Because this runs inside the same process there is no HTTP overhead, yet the response types match the Zod schemas thanks to the typed server caller + auto-generated helpers.

## 6. Try the browser hooks

Scroll down to “Client-side projects.” That entire section lives in `apps/web/src/components/projects-client-panel.tsx` and relies on the browser client + hook API:

```ts
const query = api.projects.list.useQuery();
const mutation = api.projects.create.useMutation({
  invalidate: { resource: "projects" },
});
```

`api` now exposes both `.query()` (server) and `.useQuery()`/`.useMutation()` (client) for every Fastify route. The browser client is created once in `apps/web/src/client/api.ts`, and the shared cache comes from `@fast-next/fastify-query-client`.

## 7. Run type and lint pipelines

```bash
pnpm --filter @fast-next/fastify-zod-router check-types
pnpm --filter @fast-next/fastify-server-caller check-types
pnpm --filter @fast-next/fastify-browser-client check-types
pnpm --filter web check-types
pnpm lint
```

These commands ensure every package stays type-safe while you iterate.

With the basics working you’re ready to explore the architecture and build your own feature. Continue with the next sections for deeper dives.
