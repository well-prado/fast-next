# Quickstart

Follow this checklist to get the Fast Next stack running locally and understand the moving parts before building your first feature.

## 1. Install dependencies

```bash
pnpm install
```

> pnpm 9+ is required. Node 18.18+ recommended (Next 16 + Fastify 5 support).

## 2. Scaffold the Fastify bridge (optional)

Setting up a new Next.js app? Let the CLI drop in the boilerplate routes and server helpers:

```bash
npx create-fast-next init .
pnpm dlx create-fast-next init .
yarn create fast-next init .
bunx create-fast-next init .
```

Pass `--install auto` (or `--install pnpm|npm|yarn|bun`) to have the CLI add dependencies. Need BullMQ scaffolding? Append `--with-queue`. Need caching? Use `--with-cache redis|upstash|memory`. Want MCP tooling or Docker compose? Use `--with-mcp` / `--with-docker`. Need another domain slice later? Swap `init` for `feature <name>` in any of the commands above, e.g. `npx create-fast-next feature projects`.

When Docker files are generated, run `pnpm docker:up` to boot the stack (app + Postgres + Redis + MCP) and `pnpm docker:down` when you’re done. Logs are available via `pnpm docker:logs`. Need to work with queues or MCP tools later? Use `pnpm dlx create-fast-next queue ...` or `pnpm dlx create-fast-next mcp ...` as documented in the CLI reference.

See the [CLI reference](./cli.mdx) for all options.

## 3. Run the web app (and playground)

```bash
pnpm --filter web dev
pnpm --filter fast-next-playground dev # optional playground
```

Both apps mount Fastify behind the `/api/*` catch-all route. The `web` workspace is your production UI; the `fast-next-playground` app keeps the default Next.js landing page intact and exposes a `/demo` showcase so you can test the server/client bridge in isolation.

## 4. Smoke test the HTTP path

```bash
curl http://localhost:3000/api/health
curl http://localhost:3000/api/users/1
```

Both responses come from Fastify handlers defined in `apps/web/src/server/routes/index.ts`.

## 5. Inspect the Fast Next playground

Open `http://localhost:3000/demo` (or whatever port Next picked). The view lives in `apps/fast-next-playground/app/demo/page.tsx` and is an **async Server Component** that pulls data via:

```ts
const [healthResult, projectsResult] = await Promise.all([
  api.system.health.query(),
  api.projects.list.query(),
]);
```

That `api` instance is generated by `createServerClient` (`apps/fast-next-playground/server/api.ts`) and backed by the Fastify server caller—zero HTTP hop, full type safety. The form at the bottom posts through a server action:

```ts
await api.projects.create.mutate({
  body: { name, status },
});
revalidatePath("/demo");
```

## 6. Try the browser hooks

On the same screen you’ll see “Client-side projects.” That section lives in `apps/fast-next-playground/components/projects-client-panel.tsx` and relies on the browser client + hook API:

```ts
const query = api.projects.list.useQuery();
const mutation = api.projects.create.useMutation({
  invalidate: { resource: "projects" },
});
```

`api` now exposes both `.query()` (server) and `.useQuery()`/`.useMutation()` (client) for every Fastify route. The browser client is created once in `apps/fast-next-playground/client/api.ts`, and the shared cache comes from `@fast-next/fastify-query-client`.

## 7. Run type and lint pipelines

```bash
pnpm --filter @fast-next/fastify-zod-router check-types
pnpm --filter @fast-next/fastify-server-caller check-types
pnpm --filter @fast-next/fastify-browser-client check-types
pnpm --filter web check-types
pnpm lint
```

These commands ensure every package stays type-safe while you iterate.

With the basics working you’re ready to explore the architecture and build your own feature. Continue with the next sections for deeper dives.
