# Architecture Overview

This section explains how the Fast Next stack stitches Next.js and Fastify together.

## High-level flow

```
[Next Request] -> apps/web/app/api/[...fastify]/route.ts
  -> handleNextRequest()  (adapter)
    -> fastify.inject()
      -> Fastify instance from getFastifyApp()
        -> registerRoutes() wires up serverRoutes (system, projects, ...)
```

### Fastify instance lifecycle

- `apps/web/src/server/fastify-app.ts` calls `getFastifyApp` with a `configureApp` hook.
- `@fast-next/fastify-app-factory` memoizes the instance in both module scope and `globalThis.__FAST_NEXT_FASTIFY_APP__` during development to avoid HMR leaks.
- `resetFastifyApp()` exists for future tests if you need a clean slate.

### Routing + validation

- `createRoute()` (from `@fast-next/fastify-router`) records literal `resource` + `operation` metadata alongside method, path, and schema.
- `registerRoutes(app, routes)` loops over every entry, converts the Zod schema to JSON Schema (via `@fast-next/fastify-zod-router`), and calls `app.route`.
- Because the resource/operation names stay literal, every downstream client (server or browser) can autocomplete the available endpoints.

### Next.js adapter

`apps/web/app/api/[...fastify]/route.ts` forwards all HTTP verbs to the adapter:

```ts
export const GET = handle;
export const POST = handle;
// ...
```

`handle(req)` resolves the Fastify instance, converts the `NextRequest` into an inject call, and translates the result back into `NextResponse`.

### Typed server + browser clients

- `createServerCaller(builtRouter)` fabricates Fastify `request/reply` shims so handlers can run without HTTP.
- `createServerClient(routes, caller)` walks the route metadata and exposes `api.resource.operation.query()` / `.mutate()`.
- `FastifyQueryClient` (shared cache) adds `fetchQuery`, batching, and invalidation for server-side workflows.
- `createBrowserClient(routes, options)` reuses the same metadata but wires it to `fetch` + hooks. Every endpoint gains `useQuery` or `useMutation` automatically, matching TanStack’s ergonomics.

Together these pieces provide the “define once, consume anywhere” workflow that mirrors Igniter.js’ router/controller pairing—now with native support for both server components and browser hooks.

Together these pieces provide the “define once, consume anywhere” workflow that mirrors Igniter.js’ router/controller pairing.
